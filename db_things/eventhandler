#!/usr/bin/php
<?php
	define('DONT_EXIT', true);

	chdir(dirname(__FILE__));

	$print_usage = false;
	$error = false;
	$daemon = false;
	$verbose = false;

	$getopt_exists = false;
	foreach(explode(':', get_include_path()) as $path)
	{
		if(is_file($path.'/Console/Getopt.php') && is_readable($path.'/Console/Getopt.php'))
		{
			$getopt_exists = true;
			break;
		}
	}

	if($getopt_exists)
	{
		require_once('Console/Getopt.php'); # PEAR
		$options = Console_Getopt::getopt($_SERVER['argv'], 'hdv', array('help', 'daemon', 'verbose'));
		if($options instanceof PEAR_Error)
		{
			fputs(STDERR, $options->message."\n");
			exit(1);
		}

		foreach($options[0] as $o)
		{
			switch($o[0])
			{
				case 'h': case '--help':
					$print_usage = true;
					break;
				case 'd': case '--daemon':
					$daemon = true;
					break;
				case 'v': case '--verbose':
					$verbose = true;
					break;
			}
		}

		if(!isset($options[1][0]))
		{
			if(!$print_usage) $error = true;
		}
		else $db_dir = $options[1][0];
	}
	else
	{
		fputs(STDERR, "Warning: PEAR package Console_Getopt does not exist. Switching to default options.\n\n");
		if(isset($_SERVER['argv'][1])) $db_dir = $_SERVER['argv'][1];
		else $error = true;
	}

	if($print_usage || $error)
	{
		if($error) $stream = STDERR;
		else $stream = STDOUT;

		fputs($stream, <<<EOF
Usage: {$_SERVER['argv'][0]} [Options] <Database directory>
Options:
  -h, --help:    Display this help and exit
  -d, --daemon:  Run in background
  -v, --verbose: Verbose output

EOF
		);

		if($error) exit(1);
		else exit(0);
	}

	function time_prefix()
	{
		return date('Y-m-d, H:i:s')."\t";
	}

	if($daemon)
	{
		declare(ticks=1);

		if(function_exists('pcntl_fork')) $pid = pcntl_fork();
		else $pid = -1;

		if($pid == -1) fputs(STDERR, time_prefix()."Forking failed, continuing.\n");
		elseif($pid)
		{
			fputs(STDOUT, time_prefix()."Eventhandler forked, PID ".$pid.".\n");
			exit(0);
		}
	}

	function error_handler($errno, $errstr, $errfile, $errline, $errcontext)
	{
		global $errlog;
		fputs($errlog, time_prefix());
		switch($errno)
		{
			case E_WARNING:
				fputs($errlog, "Warning: ");
				break;
			case E_NOTICE:
				fputs($errlog, "Notice: ");
				break;
			default:
				fputs($errlog, "Error ".$errno.": ");
				break;
		}

		fputs($errlog, $errstr);
		fputs($errlog, " in ".$errfile." on line ".$errline.".\n");

		global $verbose;
		if($verbose)
		{
			fputs($errlog, "Error context:\n");
			ob_start();
			var_dump($errcontext);
			$context_string = ob_get_contents();
			ob_end_clean();
			fputs($errlog, $context_string."\n");
		}
	}

	function sig_handler($signo)
	{
		global $errlog;
		fputs($errlog, time_prefix());
		switch($signo)
		{
			case SIGTERM:
				fputs($errlog, "SIGTERM (".SIGTERM.")\n");
				if(!defined('terminate')) define('terminate', true);
				break;
			case SIGINT:
				fputs($errlog, "SIGINT (".SIGINT.")\n");
				if(!defined('terminate')) define('terminate', true);
				break;
			case SIGHUP:
				fputs($errlog, "SIGHUP (".SIGHUP.")\n");
				break;
		}
	}

	if(function_exists('pcntl_signal'))
	{
		pcntl_signal(SIGTERM, "sig_handler");
		pcntl_signal(SIGINT, "sig_handler");
		if($daemon)
		{
			pcntl_signal(SIGHUP, "sig_handler");
			if(function_exists('posix_setsid'))
				posix_setsid();
		}
	}

	$USE_OB = false;
	require('../engine/include.php');

	set_time_limit(0);

	define_globals($db_dir);

	if($daemon) $errlog = fopen(DB_DIR.'/eventhandler.log', 'a');
	else $errlog = STDERR;

	set_error_handler('error_handler', E_WARNING);
	set_error_handler('error_handler', E_NOTICE);

	function arrive($fleet)
	{
		global $errlog;
		global $process;

		if($fleet->getNextArrival() > time())
			return false;

		if(function_exists('pcntl_fork'))
		{
			Classes::resetInstances(false, false);
			$pid = pcntl_fork();
		}
		else $pid = -1;

		if(!$pid || $pid == -1)
		{
			if($pid != -1) set_time_limit(30);

			if(!$fleet->arriveAtNextTarget())
			{
				fputs($errlog, time_prefix()."Warning: Couldn't complete fleet ".$process['fleet'].". The time was ".$process['time'].". Gonna process it later.\n");
				$eventfile = Classes::EventFile();
				$eventfile->addNewFleet(time()+EVENTHANDLER_INTERVAL, $process['fleet']);
			}

			Classes::resetInstances();
			if($pid != -1) exit(0);
		}
		else pcntl_waitpid($pid, &$status);
	}

	function walkthrough_users()
	{
		global $errlog;
		global $last_walked;
		$last_walked = date('Y-m-d');

		if(function_exists('pcntl_fork')) $pid = pcntl_fork();
		else $pid = -1;

		if(!$pid || $pid == -1)
		{
			fputs($errlog, "\n".time_prefix()."Walking through users...\n");
			ob_start();
			include('walkthrough_users');
			fputs($errlog, time_prefix()."Finished.\n\n");
			exit(0);
		}
		else pcntl_waitpid($pid, &$status);
	}

	__autoload('Classes');
	__autoload('Fleet');
	__autoload('Galaxy');

	$fposition = 0;

	if(date('H')*3600+date('i')*60+60 < 16200) $last_walked = false;
	else $last_walked = date('Y-m-d');

	fputs($errlog, time_prefix()."Eventhandler started.\n");

	while(true)
	{
		$event_obj = Classes::EventFile();
		while($process = $event_obj->removeNextFleet())
		{
			$fleet = new Fleet($process['fleet']);
			$users = $fleet->getUsersList();

			if($fleet->getStatus() != 1)
			{
				if($fleet->getStatus() == 0)
					fputs($errlog, time_prefix()."Notice: Fleet ".$process['fleet']." had status 0.\n");
				else
					fputs($errlog, time_prefix()."Warning: Fleet ".$process['fleet']." had status ".$fleet->getStatus().". The time was ".$process['time'].". Please re-put it into the database if you want it to be processed.\n");
			}
			else arrive($fleet);
			unset($fleet);
		}
		if(defined('terminate') && terminate)
		{
			fputs($errlog, time_prefix()."Terminated.\n");
			exit(0);
		}

		 if(date('H')*3600+date('i')*60+60 > 16200 && $last_walked != date('Y-m-d')) // 4:30 Uhr
			walkthrough_users();

		sleep(EVENTHANDLER_INTERVAL);
	}
?>

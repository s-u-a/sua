#!/usr/bin/php
<?php
	if(!isset($_SERVER['argv'][1]))
	{
		fputs(STDERR, "Usage: ".$_SERVER['argv'][0]." [Database dir]\n");
		exit(1);
	}
	
	/*declare(ticks=1);
	
	if(function_exists('pcntl_fork')) $pid = pcntl_fork();
	else $pid = -1;
	
	if($pid == -1) fputs(STDERR, "Forking failed, continuing.\n");
	elseif($pid)
	{
		fputs(STDOUT, "Eventhandler forked, PID ".$pid.".\n");
		exit(0);
	}*/
	
	function sig_handler($signo)
	{
		global $errlog;
		switch($signo)
		{
			case SIGTERM:
				fwrite($errlog, "SIGTERM (".SIGTERM.")\n");
				define('terminate', true);
				break;
			case SIGHUP:
				fwrite($errlog, "SIGHUP (".SIGHUP.")\n");
				break;
		}
	}
	
	if(function_exists('pcntl_signal'))
	{
		pcntl_signal(SIGTERM, "sig_handler");
		pcntl_signal(SIGHUP, "sig_handler");
	}
	
	$USE_OB = false;
	require('../engine/include.php');
	
	set_time_limit(0);
	
	define_globals($_SERVER['argv'][1]);
	
	__autoload('Classes');
	__autoload('Fleet');
	__autoload('Galaxy');
	
	$fposition = 0;
	
	$event_obj = Classes::EventFile();
	
	$errlog = fopen(DB_DIR.'/eventhandler.log', 'a');
	
	while(true)
	{
		while($process = $event_obj->removeNextFleet())
		{
			$fleet = Classes::Fleet($process['fleet']);
			$users = $fleet->getUsersList();
			
			if($fleet->getStatus() != 1)
			{
				if($fleet->getStatus() == 0)
					fwrite($errlog, "Notice: Fleet ".$process['fleet']." had status 0.\n");
				else
					fwrite($errlog, "Warning: Fleet ".$process['fleet']." had status ".$fleet->getStatus().". The time was ".$process['time'].". Please re-put it into the database if you want it to be processed.\n");
			}
			else
			{
				while($fleet->getStatus() == 1 && $fleet->getNextArrival() < time())
				{
					if(!$fleet->arriveAtNextTarget())
					{
						fwrite($errlog, "Warning: Couldn't complete fleet ".$process['fleet'].". The time was ".$process['time'].". Please re-put it into the database if you want it to be completed.\n");
						break;
					}
				}
			}
			unset($fleet);
			
			# Instanzen zuruecksetzen
			Classes::resetInstances();
		}
		if(defined('terminate') && terminate)
		{
			fwrite($errlog, "Terminated.\n");
			exit(0);
		}
		
		sleep(EVENTHANDLER_INTERVAL);
	}
	
	fclose($errlog);
?>
